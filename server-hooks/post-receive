#!/usr/bin/env php

<?php
/**
 * Valide and execute commands written in commit messages in the push.
 */

// Remember to add the last whitespace, it will be followed by a command.
define( "WP_CLI_TOOL", "wp " );
define( "EOL", "\n" );
define ( "COMMIT_MESSAGE_FILE", '.auto-commit-message' );

function parse_args( $args ) {

    $positional_args = array();
    $assoc_args = array();

    foreach ( $args as $arg ) {
        $positional_arg = null;
        $assoc_arg = null;

        if ( preg_match( '|^--no-([^=]+)$|', $arg, $matches ) ) {
            $assoc_arg = array( $matches[1], false );
        } elseif ( preg_match( '|^--([^=]+)$|', $arg, $matches ) ) {
            $assoc_arg = array( $matches[1], true );
        } elseif ( preg_match( '|^--([^=]+)=(.*)|s', $arg, $matches ) ) {
            $assoc_arg = array( $matches[1], $matches[2] );
        } else {
            $positional_arg = $arg;
        }

        if ( ! is_null( $assoc_arg ) ) {
            $assoc_args[] = $assoc_arg;
        } elseif ( ! is_null( $positional_arg ) ) {
            $positional_args[] = $positional_arg;
        }
    }

    return array( $positional_args, $assoc_args, );
}

function execute_commands_from_commit_messages( $oldrev, $newrev ) {
    if( strncmp( $oldrev, '0000000', 7 ) === 0 ) { // If it is the first push with the initial commit.
        $output = shell_exec( "git rev-list $newrev" );
    } else {
        $output = shell_exec( "git rev-list $oldrev..$newrev" );
    }

    // Note there will be an empty string in the returned array if output ends with the delimitor.
    $missed_revs = explode( EOL, $output );
    $missed_revs = array_reverse( $missed_revs ); // Execute commands in chronological order.
    $wpcli_commands = array();
    $files_str = ''; // Files needed to be committed after they are updated by wp-cli commands.
    foreach( $missed_revs as $rev ) {
        if ( empty( $rev ) ) { // Exclude empty split values got from explode().
            continue;
        }

        $full_commit_msg = shell_exec( "git cat-file commit $rev" );

        // Get the commit message from the commit information content,
        // it is the line which following the first empty line.
        if ( preg_match( '|^$\n^(.+)$\n|m', $full_commit_msg, $matches ) ) {
            $commit_msg = $matches[1];
            if ( preg_match( '|^([^:]+):\ (.+)$|', $commit_msg, $matches ) ) {
                $commit_type = $matches[1];
                if( $commit_type === 'cmd' ) {
                    $command = $matches[2];
                    $all_args = explode( ' ', $command );
                    if ( empty( $all_args ) ) {
                        echo 'Commit message error: The command is empty' . EOL;
                        continue;
                    }

                    $command_name = $all_args[0];
                    if ( in_array( $command_name, array( 'create', 'update' ) ) ) {
                        array_shift( $all_args );
                        list( $args, $assoc_args ) = parse_args( $all_args );
                        if ( empty( $args ) ) {
                            echo 'Commit message error: Arguments are missing in the command.';
                            continue;
                        }

                        // important! Change file path to make the wp-cli command being able to find it.
                        $file = "../" . $args[0];

                        $command = "$command_name $file " . implode( ' ', $assoc_args );
                        if ( ! is_file( $file ) || ! file_exists( $file ) ) {
                            echo 'Commit message error: The file argument is wrong. It does not exist.';
                            continue;
                        }

                        $wpcli_commands[] = WP_CLI_TOOL . $command;
                        if ( $command_name === 'create' ){
                           $files_str .= ' ' . $args[0];
                        }
                    }
                }
            }
            else {
                echo "Commit message error: It must be format of <commit-type>: <commit-message>\n";
            }
        } else {
            echo "Commit message error: commit message is empty for commit $rev\n";
        }
    }// foreach

    // Run each wp-cli command
    if ( ! empty( $wpcli_commands ) ) {
        echo "--------------------------------\n";
        echo "Execute commands\n";
        foreach( $wpcli_commands as $c ) {
            echo "--------------------------------\n";
            echo 'Execute command: ' . $c . EOL;
            echo shell_exec( $c );
        }

        // Update markdown files modified by wp-cli commands in the previous step.
        if( ! empty( $files_str ) ) {
            echo "--------------------------------\n";
            echo "Commit updated markdown files\n";
            echo "--------------------------------\n";
            echo "git add$files_str\n";
            echo shell_exec( "git add $files_str" );
            if( ! file_exists( '.auto-commit-message' ) ) {
                exec( "echo 'auto: update markdown files after push' > .auto-commit-message" );
            }
            echo shell_exec( 'git commit -F .auto-commit-message' );
        }
    }

    return true;
}

// Read one line from STDIN.
// The arguments passed in STDIN are in the form <oldrev> <newrev> <refname>.
$line = fgets( STDIN );
if( $line !== false ) { // Process only the first branch
    $token = " \n";
    $oldrev = strtok( $line, $token );
    $newrev = strtok( $token );
    $refname = strtok( $token );
    if ( $refname === "refs/heads/master" || $refname === "refs/heads/main" ) {
        $result = execute_commands_from_commit_messages( $oldrev, $newrev );
        exit( $result ? 0 : 1 );
    } else {
        echo "This is not the master/main branch\n";
    }
}

exit( 1 );
